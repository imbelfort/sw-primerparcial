import * as joint from "jointjs";

export interface SpringEntity {
  name: string;
  attributes: Array<{
    name: string;
    type: string;
    isId?: boolean;
    isRequired?: boolean;
    isAutoGenerated?: boolean; // Indica si el ID fue agregado automáticamente
  }>;
  relationships: Array<{
    type: 'OneToOne' | 'OneToMany' | 'ManyToOne' | 'ManyToMany';
    target: string;
    fieldName: string;
    mappedBy?: string;
  }>;
}

export interface GeneratedCode {
  entities: { [key: string]: string };
  repositories: { [key: string]: string };
  services: { [key: string]: string };
  controllers: { [key: string]: string };
  applicationProperties: string;
  pomXml: string;
  mainApplication: string;
}

export class SpringCodeGenerator {
  private entities: SpringEntity[] = [];
  private projectName: string = 'GeneratedSpringApp';

  constructor(projectName?: string) {
    if (projectName) {
      this.projectName = projectName;
    }
  }

  generateFromDiagram(graph: joint.dia.Graph): GeneratedCode {
    this.extractEntitiesFromGraph(graph);
    
    return {
      entities: this.generateEntities(),
      repositories: this.generateRepositories(),
      services: this.generateServices(),
      controllers: this.generateControllers(),
      applicationProperties: this.generateApplicationProperties(),
      pomXml: this.generatePomXml(),
      mainApplication: this.generateMainApplication()
    };
  }

  private extractEntitiesFromGraph(graph: joint.dia.Graph): void {
    const cells = graph.getCells();
    console.log('Total cells found:', cells.length);
    
    cells.forEach((cell, index) => {
      if (cell.isElement && cell.isElement()) {
        const element = cell as joint.dia.Element;
        const elementType = (element as any).get('type');
        const elementName = (element as any).get('name');
        
        console.log(`Cell ${index}:`, {
          type: elementType,
          name: elementName,
          isElement: cell.isElement(),
          attrs: element.attr()
        });
        
        // Detectar clases UML de diferentes maneras
        const isUmlClass = elementType && (
          elementType.includes('uml-class') || 
          elementType.includes('uml.Class') ||
          elementType.includes('Class') ||
          elementName === 'Class'
        );
        
        if (isUmlClass) {
          const name = element.attr('text/text') || 
                      element.attr('.uml-class-name-text/text') || 
                      elementName || 
                      'UnknownEntity';
          const attributes = this.extractAttributes(element);
          const relationships = this.extractRelationships(element, cells);
          
          console.log('Found UML class:', { name, attributes, relationships });
          
          this.entities.push({
            name: this.toPascalCase(name),
            attributes,
            relationships
          });
        }
      }
    });
    
    console.log('Total entities extracted:', this.entities.length);
  }

  private extractAttributes(element: joint.dia.Element): Array<{name: string, type: string, isId?: boolean, isRequired?: boolean, isAutoGenerated?: boolean}> {
    const attributes: Array<{name: string, type: string, isId?: boolean, isRequired?: boolean, isAutoGenerated?: boolean}> = [];
    
    // Extraer atributos del elemento UML de diferentes maneras
    let attributesText = element.attr('.uml-class-attributes-text/text') || '';
    
    // Si no hay atributos en el texto, intentar obtenerlos del objeto
    if (!attributesText) {
      const elementAttributes = (element as any).get('attributes') || [];
      if (Array.isArray(elementAttributes)) {
        attributesText = elementAttributes.join('\n');
      }
    }
    
    const attributeLines = attributesText.split('\n').filter((line: string) => line.trim());
    
    attributeLines.forEach((line: string) => {
      const trimmed = line.trim();
      if (trimmed) {
        const [name, type] = trimmed.split(':').map((s: string) => s.trim());
        if (name && type) {
          attributes.push({
            name: this.toCamelCase(name),
            type: this.mapUmlTypeToJava(type),
            isId: name.toLowerCase().includes('id'),
            isRequired: !type.includes('?'),
            isAutoGenerated: false // Los atributos del UML no son auto-generados
          });
        }
      }
    });

    // Lógica inteligente para IDs
    const hasExplicitId = attributes.some(attr => attr.isId);
    
    if (!hasExplicitId) {
      // Siempre agregar ID automático si no hay un ID explícito
      // Las entidades JPA necesitan un ID para funcionar correctamente
      attributes.unshift({
        name: 'id',
        type: 'Long',
        isId: true,
        isRequired: true,
        isAutoGenerated: true // Marcar como auto-generado
      });
    }

    return attributes;
  }

  private extractRelationships(element: joint.dia.Element, allCells: joint.dia.Cell[]): Array<{type: 'OneToOne' | 'OneToMany' | 'ManyToOne' | 'ManyToMany', target: string, fieldName: string, mappedBy?: string}> {
    const relationships: Array<{type: 'OneToOne' | 'OneToMany' | 'ManyToOne' | 'ManyToMany', target: string, fieldName: string, mappedBy?: string}> = [];
    const processedLinks = new Set<string>();
    
    // Buscar links que conectan con este elemento
    allCells.forEach(cell => {
      if (cell.isLink && cell.isLink()) {
        const link = cell as joint.dia.Link;
        const source = link.getSourceElement();
        const target = link.getTargetElement();
        
        if (source && target && (source.id === element.id || target.id === element.id)) {
          const linkId = `${source.id}-${target.id}`;
          const reverseLinkId = `${target.id}-${source.id}`;
          
          // Evitar procesar el mismo link dos veces
          if (processedLinks.has(linkId) || processedLinks.has(reverseLinkId)) {
            return;
          }
          processedLinks.add(linkId);
          
          const otherElement = source.id === element.id ? target : source;
          const otherName = otherElement.attr('text/text') || (otherElement as any).get('name') || 'Unknown';
          const linkType = (link as any).get('type') || 'association';
          
          // Obtener cardinalidades del link
          const sourceCardinality = this.extractCardinality(link, 'source');
          const targetCardinality = this.extractCardinality(link, 'target');
          
          // Determinar el tipo de relación basado en cardinalidades y tipo de link
          let relationshipType: 'OneToOne' | 'OneToMany' | 'ManyToOne' | 'ManyToMany';
          let isSource = source.id === element.id;
          
          if (linkType.includes('generalization')) {
            // Herencia - se maneja con @Inheritance
            return;
          }
          
          // Determinar relación basada en cardinalidades
          if (sourceCardinality === '1' && targetCardinality === '1') {
            relationshipType = 'OneToOne';
          } else if (sourceCardinality === '1' && (targetCardinality === '*' || targetCardinality === '0..*' || targetCardinality === '1..*')) {
            relationshipType = isSource ? 'OneToMany' : 'ManyToOne';
          } else if ((sourceCardinality === '*' || sourceCardinality === '0..*' || sourceCardinality === '1..*') && targetCardinality === '1') {
            relationshipType = isSource ? 'ManyToOne' : 'OneToMany';
          } else if ((sourceCardinality === '*' || sourceCardinality === '0..*' || sourceCardinality === '1..*') && 
                     (targetCardinality === '*' || targetCardinality === '0..*' || targetCardinality === '1..*')) {
            relationshipType = 'ManyToMany';
          } else {
            // Fallback: usar tipo de link para determinar relación
            if (linkType.includes('composition') || linkType.includes('aggregation')) {
              relationshipType = isSource ? 'OneToMany' : 'ManyToOne';
            } else {
              // Por defecto, asumir ManyToOne si no hay información clara
              relationshipType = 'ManyToOne';
            }
          }
          
          // Determinar el nombre del campo basado en la relación
          let fieldName = this.toCamelCase(otherName);
          if (relationshipType === 'OneToMany' || relationshipType === 'ManyToMany') {
            fieldName += 's';
          }
          
          relationships.push({
            type: relationshipType,
            target: this.toPascalCase(otherName),
            fieldName: fieldName
          });
        }
      }
    });

    return relationships;
  }

  private extractCardinality(link: joint.dia.Link, end: 'source' | 'target'): string {
    // Buscar cardinalidad en los datos del enlace primero (sistema moderno)
    if (end === 'source') {
      const sourceMultiplicity = (link as any).get('sourceMultiplicity');
      if (sourceMultiplicity) {
        return sourceMultiplicity;
      }
    } else {
      const targetMultiplicity = (link as any).get('targetMultiplicity');
      if (targetMultiplicity) {
        return targetMultiplicity;
      }
    }
    
    // Buscar en los labels del enlace (sistema moderno)
    const labels = link.get('labels') || [];
    for (const label of labels) {
      if (end === 'source' && label.id === 'source-multiplicity') {
        return label.attrs?.text?.text || '1';
      } else if (end === 'target' && label.id === 'target-multiplicity') {
        return label.attrs?.text?.text || '1';
      }
    }
    
    // Fallback: buscar en atributos antiguos (compatibilidad)
    const linkAttrs = link.attr();
    if (linkAttrs) {
      if (end === 'source') {
        return linkAttrs['.source-label']?.text || 
               linkAttrs['.uml-source-label']?.text || 
               (link as any).get('sourceCardinality') || 
               '1';
      } else {
        return linkAttrs['.target-label']?.text || 
               linkAttrs['.uml-target-label']?.text || 
               (link as any).get('targetCardinality') || 
               '1';
      }
    }
    
    // Valor por defecto
    return '1';
  }

  private generateEntities(): { [key: string]: string } {
    const entities: { [key: string]: string } = {};
    
    this.entities.forEach(entity => {
      entities[`${entity.name}.java`] = this.generateEntityCode(entity);
    });

    return entities;
  }

  private generateEntityCode(entity: SpringEntity): string {
    const packageName = this.projectName.toLowerCase();
    const imports = this.generateEntityImports(entity);
    const annotations = this.generateEntityAnnotations(entity);
    const fields = this.generateEntityFields(entity);
    const constructors = this.generateEntityConstructors(entity);
    const methods = this.generateEntityMethods(entity);

    return `package ${packageName}.model;

${imports}

${annotations}
public class ${entity.name} {
${fields}

${constructors}

${methods}
}`;
  }

  private generateEntityImports(entity: SpringEntity): string {
    const imports = [
      'import javax.persistence.*;',
      'import java.util.Objects;',
      'import java.time.LocalDateTime;'
    ];

    if (entity.relationships.length > 0) {
      imports.push('import java.util.List;');
      imports.push('import java.util.ArrayList;');
    }

    // Agregar import para JoinTable si hay relaciones ManyToMany
    const hasManyToMany = entity.relationships.some(rel => rel.type === 'ManyToMany');
    if (hasManyToMany) {
      imports.push('import javax.persistence.JoinTable;');
    }

    return imports.join('\n');
  }

  private generateEntityAnnotations(entity: SpringEntity): string {
    return `@Entity
@Table(name = "${entity.name.toLowerCase()}s")`;
  }

  private generateEntityFields(entity: SpringEntity): string {
    const fields: string[] = [];
    const usedFieldNames = new Set<string>();

    entity.attributes.forEach(attr => {
      let field = `    `;
      
      if (attr.isId) {
        field += `@Id\n    `;
        // Solo agregar @GeneratedValue si el ID fue auto-generado
        if (attr.isAutoGenerated) {
          field += `@GeneratedValue(strategy = GenerationType.IDENTITY)\n    `;
        }
      }
      
      if (attr.isRequired && !attr.isId) {
        field += `@Column(nullable = false)\n    `;
      }
      
      field += `private ${attr.type} ${attr.name};`;
      fields.push(field);
      usedFieldNames.add(attr.name);
    });

    entity.relationships.forEach(rel => {
      // Evitar duplicados de campos
      if (usedFieldNames.has(rel.fieldName)) {
        return;
      }
      
      let field = `    `;
      
      if (rel.type === 'OneToMany') {
        field += `@OneToMany(mappedBy = "${this.toCamelCase(entity.name)}", cascade = CascadeType.ALL, fetch = FetchType.LAZY)\n    `;
        field += `private List<${rel.target}> ${rel.fieldName} = new ArrayList<>();`;
      } else if (rel.type === 'ManyToOne') {
        field += `@ManyToOne(fetch = FetchType.LAZY)\n    `;
        field += `@JoinColumn(name = "${rel.fieldName}_id")\n    `;
        field += `private ${rel.target} ${rel.fieldName};`;
      } else if (rel.type === 'OneToOne') {
        field += `@OneToOne(fetch = FetchType.LAZY)\n    `;
        field += `@JoinColumn(name = "${rel.fieldName}_id")\n    `;
        field += `private ${rel.target} ${rel.fieldName};`;
      } else if (rel.type === 'ManyToMany') {
        field += `@ManyToMany(fetch = FetchType.LAZY)\n    `;
        field += `@JoinTable(name = "${entity.name.toLowerCase()}_${rel.target.toLowerCase()}",\n    `;
        field += `        joinColumns = @JoinColumn(name = "${entity.name.toLowerCase()}_id"),\n    `;
        field += `        inverseJoinColumns = @JoinColumn(name = "${rel.target.toLowerCase()}_id"))\n    `;
        field += `private List<${rel.target}> ${rel.fieldName} = new ArrayList<>();`;
      }
      
      fields.push(field);
      usedFieldNames.add(rel.fieldName);
    });

    return fields.join('\n\n');
  }

  private generateEntityConstructors(entity: SpringEntity): string {
    return `    // Constructor por defecto
    public ${entity.name}() {}

    // Constructor con parámetros principales
    public ${entity.name}(${entity.attributes.filter(attr => attr.isRequired && !attr.isId).map(attr => `${attr.type} ${attr.name}`).join(', ')}) {
${entity.attributes.filter(attr => attr.isRequired && !attr.isId).map(attr => `        this.${attr.name} = ${attr.name};`).join('\n')}
    }`;
  }

  private generateEntityMethods(entity: SpringEntity): string {
    const methods: string[] = [];
    const usedMethodNames = new Set<string>();

    // Getters y Setters para atributos
    entity.attributes.forEach(attr => {
      const capitalizedName = attr.name.charAt(0).toUpperCase() + attr.name.slice(1);
      const getterName = `get${capitalizedName}`;
      const setterName = `set${capitalizedName}`;

      if (!usedMethodNames.has(getterName)) {
        methods.push(`    public ${attr.type} get${capitalizedName}() {
        return ${attr.name};
    }`);
        usedMethodNames.add(getterName);
      }

      // Generar setter para todos los campos (incluyendo IDs)
      if (!usedMethodNames.has(setterName)) {
        methods.push(`    public void set${capitalizedName}(${attr.type} ${attr.name}) {
        this.${attr.name} = ${attr.name};
    }`);
        usedMethodNames.add(setterName);
      }
    });

    // Getters y Setters para relaciones
    entity.relationships.forEach(rel => {
      const capitalizedName = rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1);
      const getterName = `get${capitalizedName}`;
      const setterName = `set${capitalizedName}`;

      if (!usedMethodNames.has(getterName)) {
        const returnType = rel.type === 'OneToMany' ? `List<${rel.target}>` : rel.target;
        methods.push(`    public ${returnType} get${capitalizedName}() {
        return ${rel.fieldName};
    }`);
        usedMethodNames.add(getterName);
      }

      if (!usedMethodNames.has(setterName)) {
        const paramType = rel.type === 'OneToMany' ? `List<${rel.target}>` : rel.target;
        methods.push(`    public void set${capitalizedName}(${paramType} ${rel.fieldName}) {
        this.${rel.fieldName} = ${rel.fieldName};
    }`);
        usedMethodNames.add(setterName);
      }
    });

    // equals y hashCode
    const idField = entity.attributes.find(attr => attr.isId);
    if (idField) {
      methods.push(`    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ${entity.name} ${entity.name.toLowerCase()} = (${entity.name}) o;
        return Objects.equals(${idField.name}, ${entity.name.toLowerCase()}.${idField.name});
    }

    @Override
    public int hashCode() {
        return Objects.hash(${idField.name});
    }`);
    }

    // toString
    methods.push(`    @Override
    public String toString() {
        return "${entity.name}{" +
${entity.attributes.map(attr => `                "${attr.name}=" + ${attr.name} +`).join('\n')}
                '}';
    }`);

    return methods.join('\n\n');
  }

  private generateRepositories(): { [key: string]: string } {
    const repositories: { [key: string]: string } = {};
    
    this.entities.forEach(entity => {
      repositories[`${entity.name}Repository.java`] = this.generateRepositoryCode(entity);
    });

    return repositories;
  }

  private generateRepositoryCode(entity: SpringEntity): string {
    const packageName = this.projectName.toLowerCase();
    const idType = entity.attributes.find(attr => attr.isId)?.type || 'Long';
    
    // Buscar campos de texto para búsquedas
    const textFields = entity.attributes.filter(attr => 
      attr.type === 'String' && !attr.isId
    );
    
    // Buscar campos de fecha para consultas temporales
    const dateFields = entity.attributes.filter(attr => 
      attr.type === 'LocalDateTime' && !attr.isId
    );

    return `package ${packageName}.repository;

import ${packageName}.model.${entity.name};
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface ${entity.name}Repository extends JpaRepository<${entity.name}, ${idType}> {
    
    // Métodos de consulta personalizados
${textFields.length > 0 ? `    List<${entity.name}> findBy${textFields[0].name.charAt(0).toUpperCase() + textFields[0].name.slice(1)}ContainingIgnoreCase(String ${textFields[0].name});` : '    // No hay campos de texto para búsquedas'}
    
${dateFields.length > 0 ? `    @Query("SELECT e FROM ${entity.name} e WHERE e.${dateFields[0].name} >= :startDate")
    List<${entity.name}> findBy${dateFields[0].name.charAt(0).toUpperCase() + dateFields[0].name.slice(1)}After(@Param("startDate") java.time.LocalDateTime startDate);` : '    // No hay campos de fecha para consultas temporales'}
    
    @Query("SELECT COUNT(e) FROM ${entity.name} e")
    long countAll();
}`;
  }

  private generateServices(): { [key: string]: string } {
    const services: { [key: string]: string } = {};
    
    this.entities.forEach(entity => {
      services[`${entity.name}Service.java`] = this.generateServiceCode(entity);
    });

    return services;
  }

  private generateServiceCode(entity: SpringEntity): string {
    const packageName = this.projectName.toLowerCase();
    const idField = entity.attributes.find(attr => attr.isId);
    const idType = idField?.type || 'Long';
    const idName = idField?.name || 'id';
    
    // Determinar si el ID es generado automáticamente
    const isAutoGenerated = idField?.isAutoGenerated || false;

    return `package ${packageName}.service;

import ${packageName}.model.${entity.name};
import ${packageName}.repository.${entity.name}Repository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;
import java.util.Optional;

@Service
@Transactional
public class ${entity.name}Service {
    
    @Autowired
    private ${entity.name}Repository ${entity.name.toLowerCase()}Repository;
    
    public List<${entity.name}> findAll() {
        return ${entity.name.toLowerCase()}Repository.findAll();
    }
    
    public Optional<${entity.name}> findById(${idType} id) {
        return ${entity.name.toLowerCase()}Repository.findById(id);
    }
    
    public ${entity.name} save(${entity.name} ${entity.name.toLowerCase()}) {
        return ${entity.name.toLowerCase()}Repository.save(${entity.name.toLowerCase()});
    }
    
    public ${entity.name} update(${idType} id, ${entity.name} ${entity.name.toLowerCase()}) {
        if (${entity.name.toLowerCase()}Repository.existsById(id)) {
            ${isAutoGenerated ? `// No setear ID para entidades con @GeneratedValue - Hibernate lo maneja automáticamente` : `${entity.name.toLowerCase()}.set${idName.charAt(0).toUpperCase() + idName.slice(1)}(id);`}
            return ${entity.name.toLowerCase()}Repository.save(${entity.name.toLowerCase()});
        }
        throw new RuntimeException("${entity.name} not found with id: " + id);
    }
    
    public void deleteById(${idType} id) {
        ${entity.name.toLowerCase()}Repository.deleteById(id);
    }
    
    public boolean existsById(${idType} id) {
        return ${entity.name.toLowerCase()}Repository.existsById(id);
    }
    
    public long count() {
        return ${entity.name.toLowerCase()}Repository.count();
    }
}`;
  }

  private generateControllers(): { [key: string]: string } {
    const controllers: { [key: string]: string } = {};
    
    this.entities.forEach(entity => {
      controllers[`${entity.name}Controller.java`] = this.generateControllerCode(entity);
    });

    return controllers;
  }

  private generateControllerCode(entity: SpringEntity): string {
    const packageName = this.projectName.toLowerCase();
    const idType = entity.attributes.find(attr => attr.isId)?.type || 'Long';

    return `package ${packageName}.controller;

import ${packageName}.model.${entity.name};
import ${packageName}.service.${entity.name}Service;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/${entity.name.toLowerCase()}s")
@CrossOrigin(origins = "*")
public class ${entity.name}Controller {
    
    @Autowired
    private ${entity.name}Service ${entity.name.toLowerCase()}Service;
    
    @GetMapping
    public ResponseEntity<List<${entity.name}>> getAll${entity.name}s() {
        List<${entity.name}> ${entity.name.toLowerCase()}s = ${entity.name.toLowerCase()}Service.findAll();
        return ResponseEntity.ok(${entity.name.toLowerCase()}s);
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<${entity.name}> get${entity.name}ById(@PathVariable ${idType} id) {
        Optional<${entity.name}> ${entity.name.toLowerCase()} = ${entity.name.toLowerCase()}Service.findById(id);
        return ${entity.name.toLowerCase()}.map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }
    
    @PostMapping
    public ResponseEntity<${entity.name}> create${entity.name}(@RequestBody ${entity.name} ${entity.name.toLowerCase()}) {
        ${entity.name} saved${entity.name} = ${entity.name.toLowerCase()}Service.save(${entity.name.toLowerCase()});
        return ResponseEntity.status(HttpStatus.CREATED).body(saved${entity.name});
    }
    
    @PutMapping("/{id}")
    public ResponseEntity<${entity.name}> update${entity.name}(@PathVariable ${idType} id, @RequestBody ${entity.name} ${entity.name.toLowerCase()}) {
        try {
            ${entity.name} updated${entity.name} = ${entity.name.toLowerCase()}Service.update(id, ${entity.name.toLowerCase()});
            return ResponseEntity.ok(updated${entity.name});
        } catch (RuntimeException e) {
            return ResponseEntity.notFound().build();
        }
    }
    
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> delete${entity.name}(@PathVariable ${idType} id) {
        if (${entity.name.toLowerCase()}Service.existsById(id)) {
            ${entity.name.toLowerCase()}Service.deleteById(id);
            return ResponseEntity.noContent().build();
        }
        return ResponseEntity.notFound().build();
    }
    
    @GetMapping("/count")
    public ResponseEntity<Long> get${entity.name}Count() {
        long count = ${entity.name.toLowerCase()}Service.count();
        return ResponseEntity.ok(count);
    }
}`;
  }

  private generateApplicationProperties(): string {
    return `# Database Configuration
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=password

# JPA Configuration
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

# H2 Console (for development)
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console

# Server Configuration
server.port=8080

# Logging
logging.level.${this.projectName.toLowerCase()}=DEBUG
logging.level.org.springframework.web=DEBUG
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE`;
  }

  private generatePomXml(): string {
    return `<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.0</version>
        <relativePath/>
    </parent>
    <groupId>com.example</groupId>
    <artifactId>${this.projectName.toLowerCase()}</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>${this.projectName}</name>
    <description>Generated Spring Boot application from UML diagram</description>
    <properties>
        <java.version>11</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>`;
  }

  private generateMainApplication(): string {
    return `package ${this.projectName.toLowerCase()};

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ${this.projectName}Application {
    public static void main(String[] args) {
        SpringApplication.run(${this.projectName}Application.class, args);
    }
}`;
  }

  private mapUmlTypeToJava(umlType: string): string {
    const typeMap: { [key: string]: string } = {
      'string': 'String',
      'int': 'Integer',
      'integer': 'Integer',
      'long': 'Long',
      'float': 'Float',
      'double': 'Double',
      'boolean': 'Boolean',
      'date': 'LocalDateTime',
      'datetime': 'LocalDateTime',
      'timestamp': 'LocalDateTime'
    };

    return typeMap[umlType.toLowerCase()] || 'String';
  }

  private toPascalCase(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
  }

  private toCamelCase(str: string): string {
    return str.charAt(0).toLowerCase() + str.slice(1);
  }
}
